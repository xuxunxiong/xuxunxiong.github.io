{"meta":{"title":"浩哥的技术专栏","subtitle":"记录生活点滴","description":"记录生活点滴","author":"Harlan","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2019-08-22T09:08:09.000Z","updated":"2019-08-22T09:09:49.457Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-08-22T09:07:51.000Z","updated":"2019-08-23T06:42:54.943Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"博主 在职测试工程师 略懂python web及自动化 爱好音乐、篮球、dota"},{"title":"tags","date":"2019-08-22T09:08:00.000Z","updated":"2019-08-22T09:10:19.042Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"python高级语法","slug":"python高级语法","date":"2019-08-21T16:00:00.000Z","updated":"2019-08-22T09:42:24.981Z","comments":true,"path":"2019/08/22/python高级语法/","link":"","permalink":"http://yoursite.com/2019/08/22/python高级语法/","excerpt":"","text":"需要熟悉的函数 eval map reduce filter sorted partial 需要熟悉的编程概念 自定义数据类型 比如集合（可哈希对象才能变成集合）Python 里的字典和集合对象都是基于 哈希表（Hash Table） 实现的。判断一个东西是不是在集合里的平均时间复杂度是 O(1)，非常快 123456789101112131415方法一：def find_potential_customers_v1():\"\"\"找到去过普吉岛但是没去过新西兰的人\"\"\"for phuket_record in users_visited_phuket: is_potential = True for nz_record in users_visited_nz: if phuket_record['first_name'] == nz_record['first_name'] and \\ phuket_record['last_name'] == nz_record['last_name'] and \\ phuket_record['phone_number'] == nz_record['phone_number']: is_potential = False break if is_potential: yield phuket_record 123456789101112131415161718192021222324252627282930313233343536373839404142方法二：# encoding: utf-8# 去过普吉岛的人员数据users_visited_phuket = [ &#123;\"first_name\": \"Sirena\", \"last_name\": \"Gross\", \"phone_number\": \"650-568-0388\", \"date_visited\": \"2018-03-14\"&#125;, &#123;\"first_name\": \"James\", \"last_name\": \"Ashcraft\", \"phone_number\": \"412-334-4380\", \"date_visited\": \"2014-09-16\"&#125;]# 去过新西兰的人员数据users_visited_nz = [ &#123;\"first_name\": \"Justin\", \"last_name\": \"Malcom\", \"phone_number\": \"267-282-1964\", \"date_visited\": \"2011-03-13\"&#125;, &#123;\"first_name\": \"Albert\", \"last_name\": \"Potter\", \"phone_number\": \"702-249-3714\", \"date_visited\": \"2013-09-11\"&#125;, &#123;\"first_name\": \"James\", \"last_name\": \"Ashcraft\", \"phone_number\": \"412-334-4380\", \"date_visited\": \"2014-09-16\"&#125;]class VisitRecord: def __init__(self, first_name, last_name, phone_number, date_visited): self.first_name = first_name self.last_name = last_name self.phone_number = phone_number self.date_visited = date_visited def __hash__(self): return hash((self.first_name, self.last_name, self.phone_number)) def __eq__(self, other): if isinstance(other, VisitRecord) and hash(self) == hash(other): return True return False# 去过普吉岛但没有去过新西兰的人员数据def visited_phuket_not_nz(): return set(VisitRecord(**r) for r in users_visited_phuket) - \\ set(VisitRecord(**r) for r in users_visited_nz)if __name__ == '__main__': v = visited_phuket_not_nz() for b in v: print(b.__dict__) 函数式编程 需要熟悉的编程思想 处理批量数据时，先处理单个数据 高内聚低耦合，写出更好的面向对象而非面向过程的代码（减少静态方法，提取属性、属性方法） 不需要输出结果只用于迭代时 利用生成器（yield函数只会返回一个迭代器，数据不会存进内存，随取随用 ）优于容器类型（列表、字典、集合） 利用生成器表达式代替列表生成式 尽量使用模块提供的懒惰对象： 使用 re.finditer 替代 re.findall 直接使用可迭代的文件对象： for line in fp，而不是 for line in fp.readlines() SOLID 原则 S：单一职责原则:每个类都应该只有一种职责 O：开放-关闭原则:“类应该对扩展开放，对修改封闭。”这是一个从字面上很难理解的原则，它同样有着另外一种说法：“你应该可以在不修改某个类的前提下，扩展它的行为。”","categories":[{"name":"编程","slug":"编程","permalink":"http://yoursite.com/categories/编程/"}],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"单元测试框架学习之pytest","slug":"单元测试框架学习之pytest","date":"2019-08-21T16:00:00.000Z","updated":"2019-08-22T09:58:55.316Z","comments":true,"path":"2019/08/22/单元测试框架学习之pytest/","link":"","permalink":"http://yoursite.com/2019/08/22/单元测试框架学习之pytest/","excerpt":"","text":"1. 概述`pytest`是一个非常成熟的全功能的`Python`测试框架，主要特点有以下几点： 1234561、简单灵活，容易上手，文档丰富；2、支持参数化，可以细粒度地控制要测试的测试用例；3、能够支持简单的单元测试和复杂的功能测试，还可以用来做selenium/appnium等自动化测试、接口自动化测试（pytest+requests）;4、pytest具有很多第三方插件，并且可以自定义扩展，比较好用的如pytest-selenium（集成selenium）、pytest-html（完美html测试报告生成）、pytest-rerunfailures（失败case重复执行）、pytest-xdist（多CPU分发）等；5、测试用例的skip和xfail处理；6、可以很好的和CI工具结合，例如jenkins2、用例组织规则- 测试文件以`test_`开头（以`_test`结尾也可以） - 测试类以`Test`开头，并且不能带有 `init `方法 - 测试函数以`test_`开头 - 断言使用基本的`assert`即可3、fixture说到测试框架自然要说到setup和teardown两个方法. setup是用来做准备操作.一般用来初始化资源. teardown是用来做收尾操作.一般用了关闭资源. pytest的setup和teardown是利用@pytest.fixture这个注释来完成的.不仅可以完成初始化操作,初始化后如果有数据需要给用例使用也是非常方便! 通过@pytest.fixture()注释会在执行测试用例之前初始化操作.然后直接在测试用例的方法中就可以拿到初始化返回的参数(参数名要和初始化的方法名一样) fixture 作用域 好好看下源码的注释： 123456789101112131415161718def fixture(scope=\"function\", params=None, autouse=False, ids=None, name=None):Decorator to mark a fixture factory function.This decorator can be used, with or without parameters, to define afixture function.The name of the fixture function can later be referenced to cause itsinvocation ahead of running tests: testmodules or classes can use the ``pytest.mark.usefixtures(fixturename)``marker.Test functions can directly use fixture names as inputarguments in which case the fixture instance returned from the fixturefunction will be injected.Fixtures can provide their values to test functions using ``return`` or ``yield``statements. When using ``yield`` the code block after the ``yield`` statement is executedas teardown code regardless of the test outcome, and must yield exactly once.从以上信息得知3点： fixture默认作用域为function,另外其他几种作用域为&quot;function&quot;`` (default), ``&quot;class&quot;``,``&quot;module&quot;``, ``&quot;package&quot;`` or ``&quot;session&quot;。 fixture装饰的函数可以作为测试用例的输出参数 yield关键字后面的代码作为teardown code 4、用例的组织 运行方式： 123451. pytest目录下会先加载conftest.py运行。2. 该目录下加载test开头的py文件3. 加载文件中Test开头的类4. 加载Test类下test开头的方法5. 通过命令行pytest.main([1, 2 ,3])带入1 2 3参数进行运行 用例的执行顺序由用例的定义顺序决定 @pytest.mark.smoke装饰器，控制用例执行pytest sample.py -m smoke @pytest.mark.parametrize装饰器进行数据驱动 123456789import pytest @pytest.mark.parametrize((\"a\", \"b\", \"expected\"), [ [1, 2, 3], [10, 11, 21], [1, 1, 1], ]) def test_1(a, b, expected): assert a + b == expected 5、pytest实现多级并发的思路 多机并发 6、pytest插件 1、pytest-xdist功能：开启多个worker进程，同时执行多个测试用例，达到并发运行的效果，大大提升构建效率。 官网介绍 2、pytest-allure-adaptor功能： 生成漂亮的allure报告，持续构建推荐使用 官网介绍 3、pytest-html功能： 生成html格式报告，本地调试推荐使用 官网介绍 4、pytest-rerunfailures功能： 自动重跑失败用例 官网介绍 5、pytest-cache功能： 重跑上次失败的用例，持续集成中很实用，提高分析效率，强烈推荐。 官网介绍 6、pytest-ordering功能： 可指定一个测试套中的所有用例执行顺序。 官网介绍 7、pytest-sugar功能： 改变了pytest的默认外观，增加了一个进度条，并立即显示失败的测试。 官网介绍","categories":[{"name":"测试框架学习","slug":"测试框架学习","permalink":"http://yoursite.com/categories/测试框架学习/"}],"tags":[{"name":"pytest","slug":"pytest","permalink":"http://yoursite.com/tags/pytest/"}]},{"title":"单元测试框架学习之unittest","slug":"单元测试框架学习之unittest","date":"2019-08-21T16:00:00.000Z","updated":"2019-08-22T09:48:56.706Z","comments":true,"path":"2019/08/22/单元测试框架学习之unittest/","link":"","permalink":"http://yoursite.com/2019/08/22/单元测试框架学习之unittest/","excerpt":"","text":"1、基本概念 一般单元测试框架有以下几个概念需要了解：测试类创建–fixture–测试方法–测试套件–测试方法的加载–测试执行流程控制–测试执行 unittest的属性如下 1['BaseTestSuite', 'FunctionTestCase', 'SkipTest', 'TestCase', 'TestLoader', 'TestProgram', 'TestResult', 'TestSuite', 'TextTestResult', 'TextTestRunner', '_TextTestResult', '__all__', '__builtins__', '__doc__', '__file__', '__name__', '__package__', '__path__', '__unittest', 'case', 'defaultTestLoader', 'expectedFailure', 'findTestCases', 'getTestCaseNames', 'installHandler', 'loader', 'main', 'makeSuite', 'registerResult', 'removeHandler', 'removeResult', 'result', 'runner', 'signals', 'skip', 'skipIf', 'skipUnless', 'suite', 'util'] 2、测试类的创建 unittest.TestCase：TestCase类，所有测试用例类继承的基本类 TestCase类的属性如下 1['__call__', '__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_addSkip', '_baseAssertEqual', '_classSetupFailed', '_deprecate', '_diffThreshold', '_formatMessage', '_getAssertEqualityFunc', '_truncateMessage', 'addCleanup', 'addTypeEqualityFunc', 'assertAlmostEqual', 'assertAlmostEquals', 'assertDictContainsSubset', 'assertDictEqual', 'assertEqual', 'assertEquals', 'assertFalse', 'assertGreater', 'assertGreaterEqual', 'assertIn', 'assertIs', 'assertIsInstance', 'assertIsNone', 'assertIsNot', 'assertIsNotNone', 'assertItemsEqual', 'assertLess', 'assertLessEqual', 'assertListEqual', 'assertMultiLineEqual', 'assertNotAlmostEqual', 'assertNotAlmostEquals', 'assertNotEqual', 'assertNotEquals', 'assertNotIn', 'assertNotIsInstance', 'assertNotRegexpMatches', 'assertRaises', 'assertRaisesRegexp', 'assertRegexpMatches', 'assertSequenceEqual', 'assertSetEqual', 'assertTrue', 'assertTupleEqual', 'assert_', 'countTestCases', 'debug', 'defaultTestResult', 'doCleanups', 'fail', 'failIf', 'failIfAlmostEqual', 'failIfEqual', 'failUnless', 'failUnlessAlmostEqual', 'failUnlessEqual', 'failUnlessRaises', 'failureException', 'id', 'longMessage', 'maxDiff', 'run', 'setUp', 'setUpClass', 'shortDescription', 'skipTest', 'tearDown', 'tearDownClass'] 3、fixture 完成测试 初始化/销毁工作 &#39;setUp&#39;, &#39;tearDown&#39;–&gt;作用域：测试方法，每一个测试方法都会执行一次 &#39;setUpClass&#39;, &#39;tearDownClass&#39;–&gt;作用域：测试类，每一个测试类会执行一次 4、测试套件 unittest.TestSuite()：unittest框架的TestSuite()类是用来创建测试套件的 suite = unittest.TestSuite() TestSuite类的属性如下：（组织用例时需要用到） 1['__call__', '__class__', '__delattr__', '__dict__', '__doc__', '__eq__', '__format__', '__getattribute__', '__hash__', '__init__', '__iter__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_addClassOrModuleLevelException', '_get_previous_module', '_handleClassSetUp', '_handleModuleFixture', '_handleModuleTearDown', '_tearDownPreviousClass', '_tests', 'addTest', 'addTests', 'countTestCases', 'debug', 'run'] 说明：addTest(): addTest()方法是将测试用例添加到测试套件中，如下方，是将test_baidu模块下的BaiduTest类下的test_baidu测试用例添加到测试套件。addTests()方法是加载测试套件 12345suite = unittest.TestSuite()suite1 = suite.addTest(test_baidu.BaiduTest('test_baidu')) #加载一个py文件的测试类suite.addTests(suite1)suite.addTests(suite2) #加载多个py文件的测试类suite.addTests(discover) #discover为一个测试套件 5、测试方法的加载（简化了创建测试套件的步骤） unittest.defaultTestLoader: defaultTestLoader类 看源码得知defaultTestLoader就是对TestLoader类的实例化–defaultTestLoader = TestLoader() TestLoader实例方法包含loadTestsFromTestCase、 loadTestsFromModule 、loadTestsFromName 、loadTestsFromNames 、discover 从方法名应该可以看出用法 discover()方法可自动更具测试目录start_dir匹配查找测试用例文件（test*.py），并将查找到的测试用例组装到测试套件，因此可以直接通过run()方法执行discover。用法如下：discover=unittest.defaultTestLoader.discover(test_dir, pattern=&#39;test_*.py&#39;) 12runner=unittest.TextTestRunner()runner.run(discover) 注意discover加载的是目录文件，运行py文件会报错 6、测试套件的运行 unittest.TextTextRunner():unittest框架的TextTextRunner()类，通过该类下面的run()方法来运行suite所组装的测试用例，入参为suite测试套件。 TextTextRunner的属性如下：（组织用例时需要用到） 1['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_makeResult', 'buffer', 'descriptions', 'failfast', 'resultclass', 'run', 'stream', 'verbosity'] 12runner = unittest.TextTextRunner()runner.run(suite) 7、执行流程控制 unittest.skip():装饰器，当运行用例时，有些用例可能不想执行等，可用装饰器暂时屏蔽该条测试用例。一种常见的用法就是比如说想调试某一个测试用例，想先屏蔽其他用例就可以用装饰器屏蔽。 @unittest.skip(reason): skip(reason)装饰器：无条件跳过装饰的测试，并说明跳过测试的原因。 @unittest.skipIf(reason): skipIf(condition,reason)装饰器：条件为真时，跳过装饰的测试，并说明跳过测试的原因。 @unittest.skipUnless(reason): skipUnless(condition,reason)装饰器：条件为假时，跳过装饰的测试，并说明跳过测试的原因。 @unittest.expectedFailure(): expectedFailure()测试标记为失败。 8、测试断言 assert*():一些断言方法：在执行测试用例的过程中，最终用例是否执行通过，是通过判断测试得到的实际结果和预期结果是否相等决定的。 assertEqual(a,b，[msg=&#39;测试失败时打印的信息&#39;]):断言a和b是否相等，相等则测试用例通过。 assertNotEqual(a,b，[msg=&#39;测试失败时打印的信息&#39;]):断言a和b是否相等，不相等则测试用例通过。 assertTrue(x，[msg=&#39;测试失败时打印的信息&#39;])：断言x是否True，是True则测试用例通过。 assertFalse(x，[msg=&#39;测试失败时打印的信息&#39;])：断言x是否False，是False则测试用例通过。 assertIs(a,b，[msg=&#39;测试失败时打印的信息&#39;]):断言a是否是b，是则测试用例通过。 assertNotIs(a,b，[msg=&#39;测试失败时打印的信息&#39;]):断言a是否是b，不是则测试用例通过。 assertIsNone(x，[msg=&#39;测试失败时打印的信息&#39;])：断言x是否None，是None则测试用例通过。 assertIsNotNone(x，[msg=&#39;测试失败时打印的信息&#39;])：断言x是否None，不是None则测试用例通过。 assertIn(a,b，[msg=&#39;测试失败时打印的信息&#39;])：断言a是否在b中，在b中则测试用例通过。 assertNotIn(a,b，[msg=&#39;测试失败时打印的信息&#39;])：断言a是否在b中，不在b中则测试用例通过。 assertIsInstance(a,b，[msg=&#39;测试失败时打印的信息&#39;])：断言a是是b的一个实例，是则测试用例通过。 assertNotIsInstance(a,b，[msg=&#39;测试失败时打印的信息&#39;])：断言a是是b的一个实例，不是则测试用例通过。 9、测试运行 TextTextRunner的属性如下：（组织用例时需要用到） 1['__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_makeResult', 'buffer', 'descriptions', 'failfast', 'resultclass', 'run', 'stream', 'verbosity'] 1234run(): run()方法是运行测试套件的测试用例，入参为suite测试套件。runner = unittest.TextTestRunner()runner.run(suite) 10、利用第三方测试模板运行123456with open(report_name, 'wb') as f: runner = HTMLTestRunner(stream=f, title=ReadConfigFile().get_config_value(\"send_email\", \"subject\") + version_info, description=ReadConfigFile().get_config_value(\"send_email\", \"description\"), verbosity=6) result = runner.run(suite) 11、补充测试执行的3种方案1234567891011121314151617181920212223242526272829303132if __name__=='__main__':#8.1执行测试用例方案一如下：#unittest.main()方法会搜索该模块下所有以test开头的测试用例方法，并自动执行它们。#执行顺序是命名顺序：先执行test_case1，再执行test_case2 unittest.main()'''#8.2执行测试用例方案二如下：#8.2.1先构造测试集#8.2.1.1实例化测试套件 suite=unittest.TestSuite()#8.2.1.2将测试用例加载到测试套件中。#执行顺序是安装加载顺序：先执行test_case2，再执行test_case1 suite.addTest(Test('test_case2')) suite.addTest(Test('test_case1'))#8.2.2执行测试用例#8.2.2.1实例化TextTestRunner类 runner=unittest.TextTestRunner()#8.2.2.2使用run()方法运行测试套件（即运行测试套件中的所有用例） runner.run(suite)#8.3执行测试用例方案三如下：#8.3.1构造测试集（简化了方案二中先要创建测试套件然后再依次加载测试用例）#执行顺序同方案一：执行顺序是命名顺序：先执行test_case1，再执行test_case2 test_dir = './' discover = unittest.defaultTestLoader.discover(test_dir, pattern='test_*.py')#8.3.2执行测试用例#8.3.2.1实例化TextTestRunner类 runner=unittest.TextTestRunner()#8.3.2.2使用run()方法运行测试套件（即运行测试套件中的所有用例） runner.run(discover)''' 1234567891011121314151617181920if __name__ == '__main__': # 方法一：通过defaultTestLoader加载测试套件（测试文件） suite = unittest.defaultTestLoader.discover( r'C:\\Users\\ThinkPad\\PycharmProjects\\Practice\\test', pattern='test*.py') # 方法二：通过defaultTestLoader加载测试套件（测试文件/测试类） # suite = unittest.defaultTestLoader.loadTestsFromModule( # test_a_1, pattern='test*.py') # suite = unittest.defaultTestLoader.loadTestsFromTestCase( # Test_a_1) # 方法二：通过suite.addTests加载测试套件(测试类) # suite = unittest.TestSuite() # suite.addTests(unittest.defaultTestLoader.loadTestsFromTestCase(Test_a_1)) # 方法三：通过suite.addTest加载单个测试用例（测试方法） # suite = unittest.TestSuite() # suite.addTest(test_a_1.Test_a_1('test_1')) runner = unittest.TextTestRunner() result = runner.run(suite)","categories":[{"name":"测试框架学习","slug":"测试框架学习","permalink":"http://yoursite.com/categories/测试框架学习/"}],"tags":[{"name":"unittest","slug":"unittest","permalink":"http://yoursite.com/tags/unittest/"}]},{"title":"阿里云服务器部署flask应用","slug":"阿里云服务器部署flask应用","date":"2019-08-21T16:00:00.000Z","updated":"2019-08-22T09:58:24.556Z","comments":true,"path":"2019/08/22/阿里云服务器部署flask应用/","link":"","permalink":"http://yoursite.com/2019/08/22/阿里云服务器部署flask应用/","excerpt":"","text":"1、安装centos上安装python3和pip3 安装依赖包 1yum install zlib-devel bzip2-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gcc* make -y 下载python安装包 cd /usr/local 1wget https://www.python.org/ftp/python/3.5.2/Python-3.7.0.tar.xz 解压python安装包 1tar -Jxvf Python-3.5.2.tar.xz cd Python-3.7.0 配置安装路径 1./configure prefix=/usr/local/python3 编译安装 1make &amp;&amp; make install 配置软连接 12ln -s /usr/local/python3/bin/python3 /usr/bin/python3ln -s /usr/local/python3/bin/pip3 /usr/bin/pip3 2、安装pipenv1sudo pip3 install pipenv3、安装Nginx 安装依赖 1234yum install gccyum install pcre-develyum install zlib zlib-develyum install openssl openssl-devel 下载nginx：cd nginx wget http://nginx.org/download/nginx-1.13.7.tar.gz 解压：tar -xvf nginx-1.13.7.tar.gz 切换目录：cd nginx-1.13.7 使用默认配置：./configure 编译安装make &amp; make install 测试配置文件：/usr/local/nginx/sbin/nginx -t 启动命令：/usr/local/nginx/sbin/nginx 查看进程命令：ps -ef | grep nginx 浏览器访问：http://120.77.218.227 关闭 killall -9 nginx 配置nginx环境变量 vi /etc/profile PATH=$PATH:/usr/local/nginx/sbin export PATH 添加nginx服务，以便可以使用命令 service nginx start/stop/status 添加nginx服务链接地址 4、安装gunicorn 进入虚拟环境并安装 pipenv install gunicorn 记住要修改Nginx配置文件 /usr/local/nginx/conf/nginx.conf 1234567location / &#123; proxy_pass http://0.0.0.0:9999; proxy_set_header Host $host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; root html; index index.html index.htm; &#125; 进行项目根目录利用gunicord启动Nginx服务 gunicorn -w 4 -b 0.0.0.0:9999 flasktest:app --preload 5、安装MySQL 安装链接","categories":[{"name":"服务部署","slug":"服务部署","permalink":"http://yoursite.com/categories/服务部署/"}],"tags":[{"name":"flask","slug":"flask","permalink":"http://yoursite.com/tags/flask/"}]},{"title":"记录好用的linux命令","slug":"记录一些好用的Linux命令","date":"2019-08-21T16:00:00.000Z","updated":"2019-08-22T09:34:27.485Z","comments":true,"path":"2019/08/22/记录一些好用的Linux命令/","link":"","permalink":"http://yoursite.com/2019/08/22/记录一些好用的Linux命令/","excerpt":"","text":"查看系统启动的服务netstat -anplt 123456789101112Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State PID/Program name tcp 0 0 0.0.0.0:9999 0.0.0.0:* LISTEN 22739/python3 tcp 0 0 0.0.0.0:80 0.0.0.0:* LISTEN 24222/nginx: master tcp 0 0 0.0.0.0:22 0.0.0.0:* LISTEN 3242/sshd tcp 0 0 172.18.140.142:58358 100.100.30.26:80 ESTABLISHED 23243/AliYunDun tcp 0 36 172.18.140.142:22 116.24.153.243:10761 ESTABLISHED 23904/sshd: root@pt tcp 0 0 172.18.140.142:22 113.87.194.66:3618 ESTABLISHED 23879/sshd: root@pt tcp6 0 0 :::3306 :::* LISTEN 24453/mysqld tcp6 0 0 172.18.140.142:3306 116.24.153.243:2076 ESTABLISHED 24453/mysqld tcp6 0 0 172.18.140.142:3306 116.24.153.243:2077 ESTABLISHED 24453/mysqld tcp6 0 0 172.18.140.142:3306 116.24.153.243:2078 ESTABLISHED 24453/mysqld","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]}]}